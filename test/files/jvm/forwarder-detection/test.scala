import scala.tools.asm.{Label, MethodVisitor, Opcodes}
import scala.tools.partest.BytecodeTest
import scala.collection.JavaConverters._

/**
 * This test demonstrates the techniques that a bytecode based tools (e.g. code coverage or a debugger)
 * can use to detect the variety of forwarder methods added by Scalac.
 *
 * In addition or as an alternative to these checks, these tools may also use the line number information.
 * All artificial methods within are class are emitted with either no-line (static forwarders) or with
 * a single line number corresponding to a constructor.
 *
 * See the plans for filtering in Jacoco: [[https://github.com/jacoco/jacoco/wiki/filtering-SCALAC.MIXIN]]
 *
 * If this test breaks, Scala's bytecode patterns have changed in a way that *might* need upstream tools
 * to compensate.
 *
 * This test does not cover detection of the boilerplate methods generated by value classes (equals/hashCode)
 * or by case classes (equals/hashCode/canEqual/copy/copy$defaultN/productPrefix/productElement/productIterator, and
 * apply/unapply/unapplySeq)
 */
object Test extends BytecodeTest {
  def printForwarders(className: String): Unit = {
    val classNode = loadClassNode(className)

    println("=" * 40)
    println(f"${className}%24s | Is Forwarder?")
    println("=" * 40)
    classNode.methods.asScala.sortBy(_.name).foreach {
      m =>
        val detectingVisitor = new ForwarderDetectingMethodVisitor(className, m.name)
        m.accept(detectingVisitor)
        println(f"${m.name}%24s | ${if (detectingVisitor.isForwarder) "x" else "-"}")
    }
  }

  def show: Unit = {
    printForwarders("Forwarder")
    printForwarders("Forwarder$")
    printForwarders("ValueClass")
    printForwarders("ValueClass$")
    printForwarders("ImplicitClass")
    printForwarders("ImplicitClass$")
  }
}


final class ForwarderDetector(className: String, methodName: String) {
  def isScalaForwarder(opcode: Int, calledMethodOwner: String, calledMethodName: String, desc: String): Boolean = {
    def callingCompanionModule = calledMethodOwner == (className + "$")
    val callingImplClass       = calledMethodOwner.endsWith("$class")
    val callingImplicitClass   = calledMethodOwner.endsWith(className + "$" + methodName)
    def extensionName          = (methodName + "$extension")

    val staticForwarder          = opcode == Opcodes.INVOKEVIRTUAL && callingCompanionModule && calledMethodName == methodName
    val traitForwarder           = opcode == Opcodes.INVOKESTATIC  && callingImplClass       && calledMethodName == methodName
    val extensionMethodForwarder = opcode == Opcodes.INVOKEVIRTUAL && callingCompanionModule && calledMethodName == extensionName
    val implicitClassFactory     = opcode == Opcodes.INVOKESPECIAL && callingImplicitClass   && calledMethodName == "<init>"
    val forwards = staticForwarder || traitForwarder || extensionMethodForwarder || implicitClassFactory
    forwards
  }
}

final class ForwarderDetectingMethodVisitor(className: String, methodName: String) extends MethodVisitor(Opcodes.ASM4, null) {
  private val detector = new ForwarderDetector(className, methodName)
  private var forwarder: Boolean = false
  private var hasJump: Boolean = false

  override def visitJumpInsn(opcode: Int, label: Label) {
    // sanity check: forwarder methods should be linear
    hasJump ||= true
    super.visitJumpInsn(opcode, label)
  }

  override def visitMethodInsn(opcode: Int, owner: String, name: String, desc: String) = {
    forwarder ||= detector.isScalaForwarder(opcode, owner, name, desc)
    super.visitMethodInsn(opcode, owner, name, desc)
  }

  def isForwarder: Boolean = forwarder && !hasJump
}
